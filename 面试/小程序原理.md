## 小程序为什么不使用浏览器的线程模型？

与web网站相比，以微信为宿主的小程序更考虑安全、性能等因素，因为要考虑小程序会对微信产生安全隐患，同时要尽量达到接近原生应用的用户体验，这也是小程序为什么不沿用浏览器线程模型，而自己定制一套双线程模型的最主要两个原因。

## 什么是小程序的双线程模型？

### 浏览器是多进程的

浏览器内部架构是很复杂的，只不过在处理 GUI 渲染线程和 JavaScript 逻辑脚本线程上用了互斥、阻塞的管理模式。

- 浏览器主进程
- 网络进程
- GPU进程
- 标签页进程
    - GUI渲染线程
    - JavaScript 引擎线程
    - 定时触发器线程


webWorker 是一种主从的多线程模型,Worker 内的 JavaScript 代码不能操作 DOM，可以将其理解为线程安全的。

## 为什么小程序不是用浏览器的线程模型

小程序的宿主是微信，但是小程序的版本迭代是独立的，升级不依赖宿主，小程序的定位是小而没，用完就走，不追求在微信中实现全部的 Web 能力，所以和 Web来比能力上肯定差一些，同时具备一些微信提供的原生能力，比如原生组件、系统界别和微信生态的API等。

iframe有安全问题，需要引入额外的 JavaScript 编译器在编译过程中剔除掉一些危险的代码。

保证线程安全，就要禁止操作 DOM,有两个方法。

- Web Worker.
- Shadow Dom。

Web Worker 内的 JS 代码是无法获取 Window 和 Document 对象，也就无法操作DOM。除此之外，由于 Worker 的线程安全特性，Worker 内的代码在运行过程中不会阻塞外层的GUI渲染线程，两者可以并行。

ShadowRoot 的模式设置为 closed 就可以禁止获取到 ShadowRoot 节点，从而也无法操作其内部的 DOM,但 Shadow Dom 的兼容性比 Web Worker 更差。

简易双线程模型:worker 负责计算，将结果通过 postMessage 传递给主线程进行，主线程负责渲染。

这个模型存在比较严重的性能问题，Web Worker 非常耗费资源，除去计算资源外，与主线程的通信过程对性能的损耗也非常严重。

## 安全又高效的小程序双线程模型

- 限制UI组件类型，只允许声明指定的几个组件，使用微信内置组件
- 保证逻辑线程安全，不允许直接操作UI组件
- 能够在线更新，不依赖微信，资源托管在云端，更新独立，保证良好的安全性和性能
    - 使用混合的架构模式
    - webviwe 渲染 UI
    - 类似Web Worker的独立线程运行逻辑，与WebView的平行线程，会用客户端提供的 JavaScript 引擎运行代码，iOS的JavaScriptCore，安卓腾讯是X5内核提供的JsCore环境。不提供 DOM 操作相关API，只能通过 setData 更新数据的方式异步更新UI。
- 性能尽量提升，保证用户体验

## 事件驱动的通信方式

渲染线程和逻辑线程之间的通信方式，与Vue/React不同的是，小程序的渲染层与逻辑层之间的通信并不是在两者之间直接传递数据或事件，而是由 Natvie 作为中间媒介进行转发。

- 渲染层通过与用户的交互触发特定的事件 event
- 然后 event 被传递给逻辑层
- 逻辑层继而通过一系列的逻辑处理，数据请求，接口调用等行为将加工好的数据 data 传递给渲染层
- 最后渲染层将 data 渲染为可视化的 UI。

逻辑与渲染分离的线程分工模式一方面能够保证运行在逻辑线程沙箱内的JavaScript是线程安全的，另一方面由于渲染线程的计算量非常小从而保证了对用户交互行为的快速响应，提高了用户体验。

核心奥义：双线程是为了降低渲染线程的计算量，将性能损耗降到最低。



